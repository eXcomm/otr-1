// <copyright>
// Off The Record Messaging .NET, Copyright (c) 2013
//  based upon the original Off-the-Record Messaging library by
//    Ian Goldberg, Rob Smits, Chris Alexander,
//    Willy Lew, Lisa Du, Nikita Borisov
//    otr@cypherpunks.ca, http://www.cypherpunks.ca/otr/
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of version 2.1 of the GNU Lesser General
// Public License as published by the Free Software Foundation.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
// </copyright>
// <author>Bjorn Kuiper</author>
// <email>otr@kuiper.nu</email>

namespace OffTheRecord.Toolkit.Sesskeys
{
    #region Namespaces
    using System;
    using System.Numerics;
    using OffTheRecord.Protocol.DiffieHellman;
    using OffTheRecord.Tools;

    #endregion

    /// <summary>
    /// Off-the-Record Session Keys Program (otr_sesskeys.exe).
    /// </summary>
    public class Program
    {
        #region Fields
        private static readonly log4net.ILog Log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);
        #endregion

        #region Main
        /// <summary>
        /// Main entry point.
        /// </summary>
        /// <param name="args">Application arguments.</param>
        public static void Main(string[] args)
        {
            if (args.Length != 2)
            {
                Usage(args);
                return;
            }

            if (args[0].Length != 40)
            {
                Usage(args);
                return;
            }

            string our_x = args[0];
            string their_y = args[1];

            sesskey_gen(our_x);
            ////sesskeys_gen(sessionid, sendenc, rcvenc, &is_high, &our_y, our_x, their_y);
            ////sesskeys_make_mac(sendmac, sendenc);
            ////sesskeys_make_mac(rcvmac, rcvenc);

            return;
        }
        #endregion

        #region Private methods
        private static void Usage(string[] args)
        {
            string error_msg = string.Format(
                "Usage: {0} our_privkey their_pubkey{1}" +
                "Calculate and display our public key, the session id, two AES keys,{1}" +
                "and two MAC keys generated by the given DH private key and public key.{1}",
                args[0],
                Environment.NewLine);
            Console.WriteLine(error_msg);
            return;
        }

        private static void sesskey_gen(string our_x)
        {
            /* private key generated by libgcrypt, using different endian */
            string x = "48BFDA215C31A9F0B226B3DB11F862450A0F30DA";

            BigInteger actual = BigInteger.Parse(x, System.Globalization.NumberStyles.HexNumber);

            byte[] data = actual.ToByteArray();
            string r = Tools.General.ByteArrayToString(Endian.SwapArray(data));

            /* do DH */

            DH1536 dh1536_us = new DH1536();
            dh1536_us.GeneratePublicKey(actual);
            BigInteger our_publicKey = dh1536_us.PublicKey;

            string result = string.Empty;

            string e_result =
                "b1be99fd" + "638d2b63" +
                "4f9825f753ff7f2213ae7207a390b5df3b685a8516d63d49c3bceeb826c1cd09eb030430772193b82f1f4ab01c77e38b7eff100c0fb296bd1d6148bd205fdce3a2ec33ef9c3413eb06d1f413d52ad0747b9273783f7ee88435498b5774967da987ce10e7a2cec72ceecc8f95ceaf92edf82b3e0f69faa87de5eb4748325f82f0bc43f24984b5af2c9d3043d9871c3c952b22a5b292cdead6a67caa62c0196745ed608a6aaf8797fe5801f0506b8f8aa5" +
                "f431dc58" + "3ea584a8";

            result = Tools.General.ByteArrayToString(Endian.SwapArray(our_publicKey.ToByteArray()));

            Log.DebugFormat("expected result length: {0}, our result length: {1}", e_result.Length, result.Length);

            if (string.Compare(result, e_result, true) != 0)
            {
                throw new Exception("incorrect result");
            }

            string copy = result;
        }

        /* Generate the session id and the two encryption keys from our private
         * DH key and their public DH key.  Also indicate in *high_endp if we
         * are the "high" end of the key exchange (set to 1) or the "low" end
         * (set to 0) */
        ////void sesskeys_gen(unsigned char sessionid[20], unsigned char sendenc[16], unsigned char rcvenc[16], int *high_endp, gcry_mpi_t *our_yp,  gcry_mpi_t our_x, gcry_mpi_t their_y)
        ////{
        ////    gcry_mpi_t modulus, generator, secretv;
        ////    unsigned char *secret;
        ////    size_t secretlen;
        ////    unsigned char hash[20];
        ////    int is_high;

        ////    gcry_mpi_scan(&modulus, GCRYMPI_FMT_HEX,
        ////    (const unsigned char *)DH1536_MODULUS_S, 0, NULL);
        ////    gcry_mpi_scan(&generator, GCRYMPI_FMT_HEX,
        ////    (const unsigned char *)DH1536_GENERATOR_S, 0, NULL);
        ////    *our_yp = gcry_mpi_new(0);
        ////    gcry_mpi_powm(*our_yp, generator, our_x, modulus);
        ////    secretv = gcry_mpi_new(0);
        ////    gcry_mpi_powm(secretv, their_y, our_x, modulus);
        ////    gcry_mpi_release(generator);
        ////    gcry_mpi_release(modulus);
        ////    gcry_mpi_print(GCRYMPI_FMT_USG, NULL, 0, &secretlen, secretv);
        ////    secret = malloc(secretlen + 5);

        ////    secret[1] = (secretlen >> 24) & 0xff;
        ////    secret[2] = (secretlen >> 16) & 0xff;
        ////    secret[3] = (secretlen >> 8) & 0xff;
        ////    secret[4] = (secretlen) & 0xff;
        ////    gcry_mpi_print(GCRYMPI_FMT_USG, secret+5, secretlen, NULL, secretv);
        ////    gcry_mpi_release(secretv);

        ////    is_high = (gcry_mpi_cmp(*our_yp, their_y) > 0);

        ////    /* Calculate the session id */
        ////    secret[0] = 0x00;
        ////    gcry_md_hash_buffer(GCRY_MD_SHA1, hash, secret, secretlen+5);
        ////    memmove(sessionid, hash, 20);

        ////    /* Calculate the sending enc key */
        ////    secret[0] = is_high ? 0x01 : 0x02;
        ////    gcry_md_hash_buffer(GCRY_MD_SHA1, hash, secret, secretlen+5);
        ////    memmove(sendenc, hash, 16);

        ////    /* Calculate the receiving enc key */
        ////    secret[0] = is_high ? 0x02 : 0x01;
        ////    gcry_md_hash_buffer(GCRY_MD_SHA1, hash, secret, secretlen+5);
        ////    memmove(rcvenc, hash, 16);

        ////    *high_endp = is_high;
        ////    free(secret);
        ////}

        #endregion
    }
}
